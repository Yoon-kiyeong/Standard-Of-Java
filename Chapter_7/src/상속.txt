상속
상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.
상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.
이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.
자바에서 상속을 구현하는 방법은 아주 간단하다.
새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써 주기만 하면 된다.
클래스 간의 상속관계를 그림으로 포현한 것을 상속계층도(class hierarchy)라고 한다.
자손 클래스는 조상 클래스의 모든 멤버를 상속받기 때문에, Child클래스는 Parent클래스의 멤버들을 포함한다고 할 수 있다.
클래스는 멤버들의 집합이므로 클래스 Parent와 Child의 관계를 다음과 같이 표현할 수 있다.

만일 Parent클래스에 age라는 정수형 변수를 멤버변수로 추가하면, 자손 클래스는 조상의 멤버를 모두 상속받기 때문에, Child클래스는 자동적으로 age라는 멤버변수가 추가된 것과 같은 효과를 얻는다.

class Parent {
	int age;
}

class Child extends Parent {}

이번엔 반대로 자손인 Child클래스에 새로운 멤버로 play() 메소드를 추가해보자.

class Parent {
	int age;
}

class Child extends Parent {
	void Play() {
		System.out.println("놀자~");
	}
}

Child클래스에 새로운 코드가 추가되어도 조상인 Parent클래스는 아무런 영향도 받지 않는다.
여기서 알 수 있는 것처럼, 조상 클래스가 변경되면 자손 클래스는 자동적으로 영향을 받게 되지만, 자손 클래스가 변경되는 것은 조상 클래스에 아무런 영향을 주지 못한다.

자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.
즉, 상속에 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어나게 된다.
그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수도 있으며 이것이 상속에 사용되는 키워드가 'extends'인 이유이기도 한다.

-자손 클래스는 조상 클래스의 모든 멤버를 상속받는다.
(단, 생성자와 초기화 블럭은 상속되지 않는다.)
-자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

클래스 간의 관계 - 포함관계
지금까지 상속을 통해 클래스 간에 관계를 맺어 주고 클래스를 재사용하는 방법에 대해서 알아보았다.
상속 이외에도 클래스를 재사용하는 또 다른 방법이 있는데, 그것은 클래스 간에 '포함(composite)'관계를 맺어 주는 것이다.
클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

원(Circle)을 표현하기 위한 Circle클래스와 좌표 상의 한 점을 다루기 위한 Point클래스를 다음과 같이 작성되었다고 가정하자.
class Circle {				class Point {
	int x;	//원점의 x좌표			int x;	//x좌표
	int y;	//원점의 y좌표			int y;	//y좌표
	int r;	//반지금(radius)		}
}

Point 클래스를 재사용해서 Circle클래스를 작성한다면 다음과 같이 할 수 있을 것이다.
class Circle {				class Circle {
	int x;	//원점의 x좌표			Point c = new Point(); //원점
	int y;	//원점의 y좌표	->		int r;
	int r;	//반지금(radius)		}
}

이와 같이 한 클래스를 작성하는 데 다른 클래스를 멤버변수로 선언하여 포함시키는 것은 좋은 생각이다.
하나의 거대한 클래스를 작성하는 것보다 단위별로 여러 개의 클래스를 작성한 다음, 이 단위 클래스들을 포함관계로 재사용하면 보다 간결하고 손쉽게 클래스를 작성할 수 있다.
또한 작성된 단위 클래스들은 다른 클래스를 작성하는데 재사용될 수 있을 것이다.

class Car {
	Engine e = new Engine();	//엔진
	Door[] d = new Door[4];	//문, 문의 개수를 넷으로 가정하고 배열로 처리했다.
	//...
}

클래스 간의 관계 결정하기
클래스를 작성하는데 있어서 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것이닞 결정하는 것은 때때로 혼돈스러울 수 있다.
전에 예를 든 Circle클래스의 경우, Point클래스를 포함시키는 대신 상속관계를 맺어 주었다면 다음과 같을 것이다.

class Circle {				class Circle  extends Point {
	Point c = new Point();	->		int r;
	int r;				}
}

두 경우를 비교해 보면 Circle클래스를 작성하는데 있어서 Point클래스를 포함시키거나 상속받도록 하는 것은 결과적으로 별 차이가 없어 보인다.
그럴 때는 '~은 ~이다(is - a)'와 '~은 ~을 가지고 있다(has - a)'를 넣어서 문장을 만들어 보면 클래스 간의 관계가 보다 명확해 진다.

원(Circle)은 점(Point)이다. - Circle is a Point
원(Circle)은 점(Point)을 가지고 있다. - Circle has a Point

원은 원점(Point)과 반지름으로 구성되므로 위의 두 문장을 비교해 보면 첫 번째 문장보다 두 번째 문장이 더 옳다는 것을 알 수 있을 것이다.
이처럼 클래스를 가지고 문장을 만들었을 때 '~은 ~이다'라는 문장이 성립한다면, 서로 상속관계를 맺어 주고, '~은 ~을 가지고 있다'는 문장이 성립한다면 포함관계를 맺어 주면 된다.
그래서 Circle클래스와 Point클래스 간의 관계는 상속관계보다 포함관계를 맺어 주는 것이 더 옳다.

몇 가지 더 예를 들면, Car클래스와 SportCar클래스는 'SportsCar는 Car이다'와 같이 문장을 만드는 것이 더 옳기 때문에 이 두 클래스는 Car클래스를 조상으로 하는 상속관계를 맺어 주어야 한다.
Card클래스와 Deck클래스는 'Deck은 Card를 가지고 있다.'와 같이 문장을 만드는 것이 더 옳기 때문에 Deck클래스에 Card클래스를 포함시켜야 한다.

상속관계 : '~은 ~이다. (is - a)'
포함관계 : '~은 ~을 가지고 있다. (has - a)'

단일 상속(single inheritance)
또 다른 객체지향언어인 C++에서는 여러 조상 클래스로부터 상속받는 것이 가능한 '다중 상속(multiple inheritance)'을 허용하지만 자바에서는 단일 상속만 허용한다.
그래서 둘 이상의 클래스로부터 상속을 받을 수 없다.
예를 들어 Tv클래스와 DVD클래스가 있을 때, 이 두 클래스로부터 상속을 받는 TvDVD클래스를 작성할 수 없다.
그래서 TvDVD클래스는 조상 클래스로 Tv클래스와 DVD클래스 중 하나만 선택해야 한다.

class TvDVD extends Tv, DVD { //에러. 조상은 하나만 허용된다.
	//...
}

다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 있지만, 클래스간의 관계가 매우 복잡해진다는 것과 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할수 있는 방법이 없다는 단점을 가지고 있다.
만일 다중상속을 허용해서 TvDVD크래스가 Tv클래스와 DVD클래스를 모두 조상으로 하여 두 클래스의 멤버들을 상속받는다고 가정해 보자.
Tv클래스에도 power()라는 메소드가 있고, DVD클래스에도 power()라는 메소드가 있을 때 자손인 TvDVD클래스는 어느 조상클래스의 power()를 상속받게 되는 것일까?
둘 다 상속받게 된다면, TvDVD클래스 내에서 선언부(이름과 매개변수)만 같고 서로 다른 내용의 두 메소드를 어떻게 구별할 것인가?
static메소드라면 메소드 이름 앞에 클래스의 이름을 붙여서 구별할 수 있다지만, 인스턴스 메소드의 경우 선언부가 같은 두 메소드를 구별할 수 있는 방법은 없다.
이것을 해결하는 방법은 조상 클래스의 메소드의 이름이나 매개변수를 바꾸는 방법 밖에 없다.
이렇게 하면 그 조상 클래스의 power()메소드를 사용하는 모든 클래스들도 변경을 해야 하므로 그리 간단한 문제가 아니다.

자바에서는 다중상속의 이러한 문제점을 해결하기 위해 다중상속의 장점을 포기하고 단일상속만을 허용한다.
단일 상속이 하나의 조상 클래스만을 가질 수 있기 때문에 다중상속에 비해 불편한 점도 있지만, 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 점에서 다중 상속보다 유리하다.

Object클래스 - 모든 클래스의 조상
Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스이다. 
다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.
만일 다음과 같이 다른 클래스로부터 상속을 받지 않는 Tv클래스를 정의하였다고 하자.

class Tv {				class Tv extends object {
	...		->		...
}				}

위의 코드를 컴파일 하면 컴파일러는 위의 코드를 다음과 같이 자동적으로 'extends Object'를 추가하여 Tv클래스가 Object클래스로부터 상속받도록 한다.

이렇게 함으로써 Object클래스가 모든 클래스의 조상이 되도록 한다. 만일 다른 클래스로부터 상속을 받는다고 하더라도 상속계층도를 따라 조상클래스, 조상클래스의 조상클래스를 찾아 올라가다 보면 결국 마지막 최상위 조상은 Object클래스일 것이다.
(참고 : 이미 어떤 클래스로부터 상속받도록 작성된 클래스에 대해서는 컴파일러가 'extends Object'를 추가하지 않는다.)

class Tv {	//extends Object가 자동 추가됨
	...
}

class SmartTv extends Tv {
	...
}

위와 같이 Tv클래스가 있고, Tv클래스를 상속받는 SmartTv가 있을 때 상속계층도는 다음과 같다.
(참고 : 상속계층도를 단순화하기 위해서 Object클래스를 생략하는 경우가 많다.)

이처럼 모든 상속계층도의 최상위에는 Object클래스가 위치한다. 그래서 자바의 모든 클래스들은 Object클래스의 멤버들을 상속 받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있다.
주요 메소드로는 toString()과 equals(Object o)등이 있다.
