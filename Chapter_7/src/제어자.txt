제어자(modifier)
제어자(modifier)는 클래스, 변수 또는 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

접근 제어자 : public, protected, (default), private
그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp

제어자는 클래스나 멤버변수와 메소드에 주로 사용되며, 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 간으하다.
단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다. 즉, 하나의 대상에 대해서 public과 private를 함께 사용할 수 없다는 것이다.
(참고 : 제어자들 간의 순서는 관계 없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.)

접근 제어자 외에도 여러 제어자가 있으나, static, final, abstract를 제외하고는 자주 사용되지 않는다.

static - 클래스의, 공통적인
static은 '클래스의' 또는 '공통적인'의 의미를 가지고 있다. 인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스 변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다.
그 이유는 하나의 클래스 변수를 모든 인스턴스가 공유하기 때문이다.
static이 붙은 멤버변수와 메소드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.
인스턴스메소드와 static메소드의 근본적인 차이는 메소드 내에서 인스턴스 멤버를 사용하는가의 여부에 있다.

static이 사용될 수 있는 곳 - 멤버변수, 메소드, 초기화 블럭

제어자	대상			의미
	멤버변수	- 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
		- 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
static		- 클래스가 메모리에 로드될 때 생성된다.

	메소드	- 인스턴스를 생성하지 않고도 호출이 가능한 static 메소드가 된다.
		- static메소드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.

인스턴스 멤버를 사용하지 않는 메소드는 static을 붙여서 static메소드로 선언하는 것을 고려해보도록 하자.
가능하다면 static메소드로 하는 것이 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠르다.

class staticTest {
	static int width = 200;	//클래스 변수(static 변수)
	static int height = 120;	//클래스 변수(static 변수)

	static {			//클래스 초기화 블럭
		//static변수의 복잡한 초기화 수행
	}

	static int max(int a, int b) {	//클래스 메소드(static 메소드)
		return a > b ? a : b;
	}
}

final - 마지막의, 변경될 수 없는
final은 '마지막의' 또는 '변경될 수 없는'의 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.
변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메소드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

final이 사용될 수 있는 곳 - 클래스, 메소드, 멤버변수, 지역변수

제어자	대상			의미
	클래스	변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
		그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
final	메소드	변경될 수 없는 메소드, final로 지정된 메소드는 오버라이딩을 통해 재정의 될 수 없다.
	멤버변수	변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.
	지역변수	변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

(참고 : final클래스의 대표적인 예는 String과 Math 이다.

final class FinalTest {			//조상이 될 수 없는 클래스
	final int MAX_SIZE = 10;		//값을 변경할 수 없는 멤버변수(상수)

	final void getMaxSize() {		//오버라이딩할 수 없는 메소드)변경불가)
		final int LV = MAX_SIZE;	//값을 변경할 수 없는 지역변수(상수)
		return MAX_SIZE;
	}
}

abstract - 추상의, 미완성의
abstract는 '미완성의' 의미를 가지고 있다. 메소드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메소드를 선언하는데 사용된다.
그리고 클래스에 사용되어 클래스 내에 추상메소드가 존재한다는 것을 쉽게 할 수 있게 한다.

abstract가 사용될 수 있는 곳 - 클래스, 메소드

제어자	대상			의미
abstract	클래스	클래스 내에 추상 메소드가 선언되어 있음을 의미한다.
	메소드	선언부만 작성하고 구현부는 작성하지 않은 추상 메소드임을 알린다.

abstract class AbstractTest {		//추상 메소드(추상 메소드를 포함한 클래스)
	abstract void move();	//추상 메소드(구현부가 없는 메소드)
}

추상 클래스는 아직 완성되지 않은 메소드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.

AbstractTest a = new AbstractTest();	//에러, 추상 클래스의 인스턴스 생성불가

접근 제어자(access modifier)
접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지는 않는다. 클래스나 멤버변수, 메소드, 생성자에 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻한다.

접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메소드, 생성자

private		같은 클래스 내에서만 접근이 가능하다.
(default) 		같은 패키지 내에서만 접근이 가능하다.
protected	같은 패키지 내에서, 그리고 달느 패키지의 자손클래스에서 접근이 가능하다.
public		접근 제한이 전혀 없다.

접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 왼쪽부터 나열하면 다음과 같다

접근제한없음	같은 패키지 + 자손		같은 패키지	같은 클래스
public	      >		protected    >	(default)	      >	private

public은 접근 제한이 전혀 없는 것이고, private은 같은 클래스 내에서만 사용하도록 제한하는 가장 높은 제한이다.
그리고 default는 같은 패키지내의 클래스에서만 접근이 가능하도록 하는 것이다.
마지막으로 protected는 패키지에 관계없이 상속관계에 있는 자손클래스에서 접근할 수 있도록 하는 것이 제한목적이지만, 같은 패키지 내에서도 접근이 가능하다.
그래서 protected가 default보다 접근 범위가 더 넓다.

(참고 : 접근 제어자가 default라는 것은 아무런 접근 제어자도 붙이지 않는 것을 의미한다,)

캡슐화와 접근 제어자
클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.
이것을 데이터 감추기(data hiding)라고 하며, 객체지향개념의 캡슐화(encapsulation)에 해당하는 내용이다.
또 다른 이유는 클래스 내에서만 사용되는, 냅누 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메소드 등의 멤버들을 클래스 내부에 감추기 위해서이다.
외부에서 접근할 필요가 없는 멤보들을 private으로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄일 수 있다. 이것 역시 캡슐화에 해당한다.

접근 제어자를 사용하는 이유
- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필ㄹ요한, 내부적으로만 사용되는, 부분을 감추기 위해서

예를 들어, 시간을 표시하기 위한 클래스 Time이 다음과 같이 정의되어 있을 때, 이 클래스의 인스턴스를 생성한 다음, 멤버변수에 직접 접근하여 값을 변경할 수 있을 것이다.

public class Time {
	public int hour;
	public int minute;
	public int second;
}

time t = new Time();
t.hour = 25;		//멤버변수에 직접 접근

멤버변수 hour는 0보다 같거나 크고 24보다는 작은 범위의 값을 가져야 하지만 위의 코드에서처럼 잘못된 값을 지정한다고 해도 이것을 막을 방법은 없다.
이런 경우 멤버변수를 private이나 protected로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 public메소드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 하는 것이 바람직하다.

public class Time {
	private int hour;
	private int minute;
	private int second;

	public int getHour() { return hour; }
	public void setHour(int hour) {
		if ( hour < 0 || hour > 23) return;
		this.hour = hour;
	}
	public int getMinute() { return minute; }
	public void setMinute(int minute) {
		if (minute < 0 || minute >59) return;
		this.minute = minute;
	}
	public int getSecond() {return second; }
	public void setSecond(int second) {
		if (second < 0 || second > 59) return;
		this.second = second;
	}
}

get으로 시작하는 메소드는 단순히 멤버변수의 값을 반환하는 일을 하고, set으로 시작하는 메소드는 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경하도록 작성되어 있다.
만일 상속을 통해 확장될 것이 예상되는 클래스라면 멤버에 접근 제한을 주되 자손클래스에서 접근하는 것이 가능하도록 하기 위해 private대신 protected를 사용한다.
privated가 붙은 멤버는 자손 클래스에서도 접근이 불가능 하기 때문이다.

보통 멤버변수의 값을 읽는 메소드의 이름을 'get멤버변수이름'으로 하고, 멤버변수의 값을 변경하는 메소드의 이름을 'set멤버변수이름'으로 한다.
반드시 그래야 하는 것은 아니지만 암묵적인 규칙이므로 특별한 이유가 없는 한 따르도록 하자.
그리고 get으로 시작하는 메소드를 '겟터(getter)', set으로 시작하는 메소드를 '셋터(setter)'라고 부른다.