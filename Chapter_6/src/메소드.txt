메소드란?
'메소드(Method)'란 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
기본적으로 수학의 함수와 유사하며, 어떤 값을 입려갛면 이 값으로 작업을 수행해서 결과를 반환한다.
예를 들어 제곱근을 구하는 메소드 'Math.sqrt()'는 4.0을 입력하면, 2.0을 결과로 반환한다.
(참고 : 수학의 함수와 달리 메소드는 입력값 또는 출력값(결괏값)이 없을 수도 있으며, 심지어는 입력값과 출력값이 모두 없을 수도 있다)

그저 메소드가 작업을 수행하는데 필요한 겂만 넣고 원하는 결과를 얻으면 될 뿐, 이 메소드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다.
즉, 메소드에 넣을 값(입력)과 반환하는 결과(출력)만 알면 되는 것이다. 그래서 메소드를 내부가 보이지 않는 '블랙박스(black box)'라고도 한다.
sqrt()외에도 지금까지 빈번히 사용해온 println()이나 random()과 같은 메소드들 역시 내부적으로 어떻게 동작하는지 몰라도 사용하는데 아무런 어려움이 없었다.

메소드는 크게 두 부분, '선언부(header, 머리)'와 '구현부(body, 몸통)'로 이루어져 있다. 메소드를 정의한다는 것은 선언부와 구현부를 작성하는 것을 뜻한다.

메소드의 선언부
메소드 선언부는 '메소드의 이름'과 '매개변수 선언', 그리고 '반환타입'으로 구성되어 있으며, 메소드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보를 제공한다.
메소드의 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야한다. 메소드의 선언부를 변경하게 되면, 그 메소드가 호출되는 모든 곳이 함께 변경되어야 하기 때문이다.

매개변수 선언(Parameter declaration)
매개변수는 메소드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것이며, 필요한 값의 개수만큼 변수를 선언하며 각 변수 간의 구분은 쉼표','를 사용한다.
한 가지 주의할 점은 일반적인 변수선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다는 것이다.

int add (int x, int y) {...}	//OK.
int add (int x, y)	{...}	//에러, 매개변수 y의 타입이 없다.

선언할 수 있는 매개변수의 개수는 거의 제한이 없지만, 만일 입력해야할 값의 개수가 많은 경우에는 배열이나 참조변수를 사용하면 된다.
만일 값을 전혀 입력받을 필요가 없다면 괄호 () 안에 아무것도 적지 않는다.

반환타입 (return type)
메소드의 작업수행 결과(출력)인 '반환값(return value)'의 타입을 적는다.
단, 반환값이 없는 경우 반환타입으로 'void'를 적어야 한다.

메소드의 구현부
메소드의 선언부 다음에 오는 괄호 {}를 '메소드의 구현부'라고 하는데, 여기에 메소드를 호출했을 때 수행될 문장들을 적는다.
우리가 그 동안 작성해온 문장들은 모두 main 메소드의 구현부 {}에 속한 것들이었으므로 지금까지 하던 그대로 하면 된다.

return문
메소드의 반환타입이 'void'가 아닌 경우, 구현부 {} 안에 'return 반환값;'이 반드시 포함되어 있어야 한다.
이 문장은 작업을 수행한 결과인 반환값을 호출한 메소드로 전달하는데, 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.
여러 개의 변수를 선언할 수 있는 매개변수와 달리 return문은 단 하나의 값만 반환할 수 있는데, 메소드로의 입력(매개변수)은 여러 개일 수도 있어도 출력(반환값)은 최대 하나만 허용하는 것이다.

int add (int x, int y)
{
	int result = x + y;	//작업 결과(반환값)를 반환한다.
	return result;
}	//타입이 일치해야 한다.(int)

위의 코드에서 'return result;'는 변수 result에 저장된 값을 호출한 메소드로 반환한다. 변수 result의 타입이 int이므로 메소드 add의 반환타입이 일치하는 것을 알 수 있다.

지역변수 (local variable)
메소드 내에 선언된 변수들은 그 메소드 내에서만 사용할 수 있으므로 서로 다른 메소드라면 같은 이름의 변수를 선언해도 된다.
이처럼 메소드 내에 선언된 변수를 '지역변수(local variable)'라고 한다.
(참고 : 매개변수도 메소드 내에 선언된 것으로 간주되므로 지역변수이다)

int add (int x, int y) {
	int reuslt = x + y;
	return result;
}

int multiply (int x , int y) {
	int result = x * y;
	return result;
}

위에 정의된 메소드 add와 multiplay에 각기 선언된 변수, x, y, result는 이름만 같을 뿐 서로 다른 변수이다.

메소드의 호출
메소드를 정의했어도 호출되지 않으면 아무 일도 일어나지 않는다. 메소드를 호출해야만 구현부{} 의 문장들이 수행된다.
메소드를 호출하는 방법은 다음과 같다.
(참고 : main메소드는 프로그램 실행 시 OS에 의해 자동적으로 호출된다.)
메소드 이름(값1, 값2, ...);		//메소드를 호출하는 방법
print99danAll();			//void print99danAll()을 호출
int result = add(3, 5);		//int add(int x, int y)를 호출하고, 결과를 result에 저장

인수(argument)와 매개변수(parameter)
메소드를 호출할 때 괄호() 안에 지정해준 값들을 '인수(argument)'또는 '인자'라고 하는데, 인자의 개수와 순서는 호출된 메소드에 선언된 매개변수와 일치해야 한다.
그리고 인수는 메소드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.
만일 아래와 같이 메소드에 선언된 매개변수의 개수보다 많은 값을 괄호()에 넣거나 타입이 다른 값을 넣으면 컴파일러가 에러를 발생시킨다.

int result = add(1, 2, 3);	//에러, 메소드에 선언된 매개변수의 개수가 다름
int reuslt = add(1.0, 2.0);	//에러, 메소드에 선언된 매개변수의 타입이 다름

변환타입이 void가 아닌 경우, 메소드가 작업을 수행하고 반환한 값을 대입연산자로 변수에 저장하는 것이 보통이지만, 저장하지 않아도  문제가 되지 않는다.

int reuslt = add(3, 5);	//int add(int x, int y)의 호출결과를 result에 저장
add(3, 5);			//OK. 메소드가 add가 반환한 결과를 사용하지 않아도 된다.

메소드의 실행 흐름
다음은 두 개의 값을 매개변수로 받아서 사칙연산을 수행하는 4개의 메소드를 가진 MyMath클래스르 정의한 것이다.

class MyMath {
	long add(long a, long b) {
		long result = a + b;
		return result;	
		//return a + b;	//위의 두 줄을 이와 같이 한 줄로 간단히 할 수 있다.
	}
	long substract (long a, long b) { return a - b; }
	long multiply (long a, long b) {return a * b; }
	double divide (double a, double b) {return a / b; }
}

MyMath클래스의 'add(long a, long b)'를 호출하기 위해서는 먼저 'MyMath mm = new MyMath();'와 같이 해서, MyMath클래스의 인스턴스를 생성한 다음 참조변수 mm을 통해야 한다.

MyMath mm = new MyMath();		//먼저 인스턴스를 생성한다.
long value = mm.add(1L, 2L);		//메소드를 호출한다.
		①
long add (long a, long b) {
	long result = a + b;		//②
	return result;
}③

①main메소드에서 메소드 add를 호출한다. 인수 1L과 2L이 메소드 add의 매개변수 a,b에 각각 복사(대입)된다.
②메소드 add의 괄호{ } 안에 있는 문장들이 순서대로 수행된다.
③메소드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메소드 (main 메소드)로 되돌아와서 이후의 문장들을 실행한다.

메소드가 호출되면 지금까지 실행 중이던 메소드는 실행을 잠시 멈추고 호출된 메소드의 문장들이 실행된다.
<<<<<<< HEAD
호출된 메소드의 작업이 모두 끝나면, 다시 호출한 메소드로 돌아와 이후의 문장들을 실행한다.

return문
return문은 현재 실행중인 메소드를 종료하고 호출한 메소드로 되돌아간다.
지금까지 반환값이 있을 때만 return문을 썼지만, 원래의 반환값의 유무에 관계없이 모든 메소드에는 적어도 하나의 return문이 있어야 한다.
그런데도 반환타입이 void인 경우, return문 없이도 아무런 문제가 없었던 이유는 컴파일러가 메소드의 마지막 'return;'을 자동적으로 추가해줬기 때문이다.

void printGugudan(int dan) {
	for(int i = 1; i <= 9; i++) {
		System.out.printf("%d * %d = %d%n", dan, i, dan * i);
	}
	//return;		//반환 타입이 void이므로 생략가능, 컴파일러가 자동추가
}

그러나 반환타입이 void가 아닌 경우, 즉 반환값이 있는 경우, 반드시 return문이 있어야 한다.
return문이 없으면 컴파일 에러(error: missing return statement)가 발생한다.

int multiply (int x, int y) {
	int result = x * y;
	return result;	//반환 타입이 void가 아니므로 생략불가
}

아래의 코드는 두 값 중에서 큰 값을 반환하는 메소드이다.
이 메소드의 리턴타입이 int이고 int타입의 값을 반환하는 return문이 있지만, return문이 없다는 에러가 발생한다.
왜냐하면 if문 조건식의 결과에 따라 return문이 실행되지 않을 수도 있기 때문이다.

int max (int x, int y) {
	if (a > b) 
	return a;	//조건식이 참일 때만 실행된다.
}

그래서 이런 경우 다음과 같이 if문의 else블럭에 return문을 추가해서, 항상 결과값이 반환되도록 해야 한다.

int max (int a, int b) {
	if (a >b) 
		return a;		//조건식이 참일 때 실행된다.
	else
		return b;		//조건식이 거짓일 때 실행된다.
}

반환값
return문의 반환값으로 주로 변수가 오긴 하지만 항상 그런 것은 아니다.
아래 왼쪽의 코드는 오른쪽과 같이 간략히 할 수 있는데, 오른쪽의 코드는 return문의 반환 값으로 'x + y'라는 수식이 적혀있다.
그렇다고 해서 수식이 반환되는 것은 아니고, 이 수식을 계산한 결과가 반환된다.

int add (int x, int y) {				int add (int x, int y) {
	int result = x + y;		       <->			return x + y;
	return result;				}
}
(참고 : 수학에서처럼, result의 값이 'x + y'와 같으므로 result대신 'x + y'를 쓸 수 있다고 생각하면 이해하기 쉽다.)

예를 들어 매개변수 x와 y의 값이 각각 3과 5라면, 'return x + y;'는 다음과 같은 계산과정을 거쳐서 반환값은 8이 된다.

return x + y;
-> return 3 + 5;
return 8;

아래의 diff메소드는 두 개의 정수를 받아서 그 차이를 절대값으로 반환한다.
오른쪽 코드 역시 메소드를 반환하는 것이 아니라 메소드 abs를 호출하고, 그 결과를 ㅂ다아서 반환한다.
메소드 abs의 반환타입이 메소드 diff의 반환타입과 일치하기 때문에 이렇게 하는 것이 가능하다는 것에 주의하자.

int diff (int x, int y) {				int diff (int x, int y) {
	int result = abs (x-y);	      <->			return abs (x-y);
	return result;				}
}

간단한 메소드의 경우 if문 대신 조건연산자를 사용하기도 한다. 메소드 abs는 입력받은 정수의 부호를 판단해서 음수일 경우 부호연산자(-)를 사용해서 양수로 반환한다.

int  abs (int x) {					int abs (int x) {
	if (x >= 0) {					return x >= 0 ? x : -x;
		return x;		     <->		}
	} else {
		return -x;
	}
}

호출스택(call stack)
호출스택은 메소드의 작업에 필요한 메모리 공간을 제공한다.
메소드가 호출되면, 호출스택에 호출된 메소드를 위한 메모리가 할당되며, 이 메모리는 메소드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간 결과 등을 저장하는데 사용된다.
그리고 메소드가 작업을 마치면 할당되었던 메모리 공간들은 반환되어 비어진다.

호출스택을 조사해 보면 메소드 간의 호출 관계와 현재 수행 중인 메소드가 어느 것인지 알 수 있다.
호출스택의 특징을 정리해보면 다음과 같다.

- 메소드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
- 메소드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
- 호출스택의 제일 위에 있는 메소드가 현재 실행 중인 메소드이다.
- 아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드이다.

반환타입(return type)이 있는 메소드는 종료되면서 결과값을 자신을 호출한 메소드(caller)에게 반환한다.
대기상태에 있던 호출한 메소드(caller)는 넘겨받은 반환값으로 수행을 계속 진행하게 된다.

기본형 매개변수
자바에서는 메소드를 호출할 때 매개변수로 지정한 값을 메소드의 매개변수에 복사해서 넘겨준다.
매개변수의 타입이 기본형(primitive type)일 때는 기본형 값이 복사되겠지만, 참조형(reference type)이면 인스턴스의 주소가 복사된다.
메소드의 매개변수를 기본형을 선언하면 단순이 저장된 값만 얻지만, 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 떄문에 값을 읽어 오는 것은 물론 값을 변경하는 것도 가능하다.

기본형 매개변수 : 변수의 값을 읽김나 할 수 있다. (read only)
참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다. (read & write)4

참조형 반환타입
매개변수뿐만 아니라 반환타입도 참조형이 될 수 있다.
반환타입이 참조형이라는 것은 반환하는 값의 타입이 참조형이라는 애긴데, 모든 참조형 타입의 값은 '객체의 주소'이므로 그저 정수값이 반환되는 것일 뿐 특별한 것이 없다.
=======
호출된 메소드의 작업이 모두 끝나면, 다시 호출한 메소드로 돌아와 이후의 문장들을 실행한다.
>>>>>>> d2511c32ffa0298c37f17adf063695e6fe960b55
