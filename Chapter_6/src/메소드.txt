메소드란?
'메소드(Method)'란 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
기본적으로 수학의 함수와 유사하며, 어떤 값을 입려갛면 이 값으로 작업을 수행해서 결과를 반환한다.
예를 들어 제곱근을 구하는 메소드 'Math.sqrt()'는 4.0을 입력하면, 2.0을 결과로 반환한다.
(참고 : 수학의 함수와 달리 메소드는 입력값 또는 출력값(결괏값)이 없을 수도 있으며, 심지어는 입력값과 출력값이 모두 없을 수도 있다)

그저 메소드가 작업을 수행하는데 필요한 겂만 넣고 원하는 결과를 얻으면 될 뿐, 이 메소드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다.
즉, 메소드에 넣을 값(입력)과 반환하는 결과(출력)만 알면 되는 것이다. 그래서 메소드를 내부가 보이지 않는 '블랙박스(black box)'라고도 한다.
sqrt()외에도 지금까지 빈번히 사용해온 println()이나 random()과 같은 메소드들 역시 내부적으로 어떻게 동작하는지 몰라도 사용하는데 아무런 어려움이 없었다.

메소드는 크게 두 부분, '선언부(header, 머리)'와 '구현부(body, 몸통)'로 이루어져 있다. 메소드를 정의한다는 것은 선언부와 구현부를 작성하는 것을 뜻한다.

메소드의 선언부
메소드 선언부는 '메소드의 이름'과 '매개변수 선언', 그리고 '반환타입'으로 구성되어 있으며, 메소드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보를 제공한다.
메소드의 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야한다. 메소드의 선언부를 변경하게 되면, 그 메소드가 호출되는 모든 곳이 함께 변경되어야 하기 때문이다.

매개변수 선언(Parameter declaration)
매개변수는 메소드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것이며, 필요한 값의 개수만큼 변수를 선언하며 각 변수 간의 구분은 쉼표','를 사용한다.
한 가지 주의할 점은 일반적인 변수선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다는 것이다.

int add (int x, int y) {...}	//OK.
int add (int x, y)	{...}	//에러, 매개변수 y의 타입이 없다.

선언할 수 있는 매개변수의 개수는 거의 제한이 없지만, 만일 입력해야할 값의 개수가 많은 경우에는 배열이나 참조변수를 사용하면 된다.
만일 값을 전혀 입력받을 필요가 없다면 괄호 () 안에 아무것도 적지 않는다.

반환타입 (return type)
메소드의 작업수행 결과(출력)인 '반환값(return value)'의 타입을 적는다.
단, 반환값이 없는 경우 반환타입으로 'void'를 적어야 한다.

메소드의 구현부
메소드의 선언부 다음에 오는 괄호 {}를 '메소드의 구현부'라고 하는데, 여기에 메소드를 호출했을 때 수행될 문장들을 적는다.
우리가 그 동안 작성해온 문장들은 모두 main 메소드의 구현부 {}에 속한 것들이었으므로 지금까지 하던 그대로 하면 된다.

return문
메소드의 반환타입이 'void'가 아닌 경우, 구현부 {} 안에 'return 반환값;'이 반드시 포함되어 있어야 한다.
이 문장은 작업을 수행한 결과인 반환값을 호출한 메소드로 전달하는데, 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.
여러 개의 변수를 선언할 수 있는 매개변수와 달리 return문은 단 하나의 값만 반환할 수 있는데, 메소드로의 입력(매개변수)은 여러 개일 수도 있어도 출력(반환값)은 최대 하나만 허용하는 것이다.

int add (int x, int y)
{
	int result = x + y;	//작업 결과(반환값)를 반환한다.
	return result;
}	//타입이 일치해야 한다.(int)

위의 코드에서 'return result;'는 변수 result에 저장된 값을 호출한 메소드로 반환한다. 변수 result의 타입이 int이므로 메소드 add의 반환타입이 일치하는 것을 알 수 있다.

지역변수 (local variable)
메소드 내에 선언된 변수들은 그 메소드 내에서만 사용할 수 있으므로 서로 다른 메소드라면 같은 이름의 변수를 선언해도 된다.
이처럼 메소드 내에 선언된 변수를 '지역변수(local variable)'라고 한다.
(참고 : 매개변수도 메소드 내에 선언된 것으로 간주되므로 지역변수이다)

int add (int x, int y) {
	int reuslt = x + y;
	return result;
}

int multiply (int x , int y) {
	int result = x * y;
	return result;
}

위에 정의된 메소드 add와 multiplay에 각기 선언된 변수, x, y, result는 이름만 같을 뿐 서로 다른 변수이다.

메소드의 호출
메소드를 정의했어도 호출되지 않으면 아무 일도 일어나지 않는다. 메소드를 호출해야만 구현부{} 의 문장들이 수행된다.
메소드를 호출하는 방법은 다음과 같다.
(참고 : main메소드는 프로그램 실행 시 OS에 의해 자동적으로 호출된다.)
메소드 이름(값1, 값2, ...);		//메소드를 호출하는 방법
print99danAll();			//void print99danAll()을 호출
int result = add(3, 5);		//int add(int x, int y)를 호출하고, 결과를 result에 저장

인수(argument)와 매개변수(parameter)
메소드를 호출할 때 괄호() 안에 지정해준 값들을 '인수(argument)'또는 '인자'라고 하는데, 인자의 개수와 순서는 호출된 메소드에 선언된 매개변수와 일치해야 한다.
그리고 인수는 메소드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.
만일 아래와 같이 메소드에 선언된 매개변수의 개수보다 많은 값을 괄호()에 넣거나 타입이 다른 값을 넣으면 컴파일러가 에러를 발생시킨다.

int result = add(1, 2, 3);	//에러, 메소드에 선언된 매개변수의 개수가 다름
int reuslt = add(1.0, 2.0);	//에러, 메소드에 선언된 매개변수의 타입이 다름

변환타입이 void가 아닌 경우, 메소드가 작업을 수행하고 반환한 값을 대입연산자로 변수에 저장하는 것이 보통이지만, 저장하지 않아도  문제가 되지 않는다.

int reuslt = add(3, 5);	//int add(int x, int y)의 호출결과를 result에 저장
add(3, 5);			//OK. 메소드가 add가 반환한 결과를 사용하지 않아도 된다.

메소드의 실행 흐름
다음은 두 개의 값을 매개변수로 받아서 사칙연산을 수행하는 4개의 메소드를 가진 MyMath클래스르 정의한 것이다.

class MyMath {
	long add(long a, long b) {
		long result = a + b;
		return result;	
		//return a + b;	//위의 두 줄을 이와 같이 한 줄로 간단히 할 수 있다.
	}
	long substract (long a, long b) { return a - b; }
	long multiply (long a, long b) {return a * b; }
	double divide (double a, double b) {return a / b; }
}

MyMath클래스의 'add(long a, long b)'를 호출하기 위해서는 먼저 'MyMath mm = new MyMath();'와 같이 해서, MyMath클래스의 인스턴스를 생성한 다음 참조변수 mm을 통해야 한다.

MyMath mm = new MyMath();		//먼저 인스턴스를 생성한다.
long value = mm.add(1L, 2L);		//메소드를 호출한다.
		①
long add (long a, long b) {
	long result = a + b;		//②
	return result;
}③

①main메소드에서 메소드 add를 호출한다. 인수 1L과 2L이 메소드 add의 매개변수 a,b에 각각 복사(대입)된다.
②메소드 add의 괄호{ } 안에 있는 문장들이 순서대로 수행된다.
③메소드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메소드 (main 메소드)로 되돌아와서 이후의 문장들을 실행한다.

메소드가 호출되면 지금까지 실행 중이던 메소드는 실행을 잠시 멈추고 호출된 메소드의 문장들이 실행된다.
호출된 메소드의 작업이 모두 끝나면, 다시 호출한 메소드로 돌아와 이후의 문장들을 실행한다.