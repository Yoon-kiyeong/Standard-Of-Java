오버로딩(Overloading)
메소드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 하기 때문에 각기 다른 이름을 가져야 한다.
그러나 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.
이처럼, 한 클래스 내에 같은 이름의 메소드를 여러 개 정의하는 것을 '메소드 오버로딩(method overloading)'또는 간단히 '오버로딩(overloading)'이라고 한다.
같은 이름의 메소드를 정의한다고 해서 무조건 오버로딩인 것은 아니다. 오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야 한다.
1. 메소드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 반환 타입은 관계없다.

비록 메소드의 이름이 같다 하더라도 매개변수가 다르면 서로 구별될 수 있기 때문에 오버로딩이 가능한 것이다.
위의 조건을 만족시키지 못하는 메소드는 중복 정의로 간주되어 컴파일 시에 에러가 발생한다.
그리고 오버로딩된 메소드들은 매개변수에 의해서만 구별될 수 있으므로 반환 타입은 오버로딩을 구현하는데 어무런 영향을 주지 못한다는 것에 주의하자.
오버로딩의 예로 가장 대표적인 것은 println메소드이다. 지금까지 우리는 println메소드의 괄호 안에 값만 지정해주면 화면에 출력하는데 아무런 어려움이 없었다.
하지만, 실제로는 println메소드를 호출할 때 매개변수로 지정하는 값의 타입에 따라서 호출되는 println메소드가 달라진다.
PrintStream클래스에는 어떤 종류의 매개변수를 지정해도 출력할 수 있도록 아래와 같이 10개의 오버로딩된 println메소드를 정의해놓고 있다.

void println()
void println(boolean x)
void println(char x)
void println(char[] x)
void println(double x)
void println(float x)
void println(int x)
void println(long x)
void println(Object x)
void println(String x)

println메소드를 호출할 때 매개변수로 넘겨주는 값의 타입에 따라서 위의 오버로딩된 메소드들 중의 하나가 선택되어 실행되는 것이다.
ex)
int add(int a, int b) { return a + b;}
int add(int x, int y) { return a + b;}

위의 두 메소드는 매개변수의 이름만 다를 뿐 매개변수의 타입이 같기 때문에 오버로딩이 성립하지 않는다.
매개변수의 이름이 다르면 메소드 내에서 사용되는 변수의 이름이 달라질 뿐, 아무런 의미가 없다.
그래서 이 두 메소드는 정확히 같은 것이다. 마치 수학에서 'f(x) = x + 1'과 'f(a)= a + 1'이 같은 표현인 것과 같다.
컴파일 하면, 'add(int, int) is already defined(이미 같은 메소드가 정의되었다).'라는 메시지가 나타날 것이다.

int add(int a, int b) { return a + b;}
long add(int a, int b) {return a + b;}

이번 경우는 리턴타입만 다른 경우이다. 매개변수의 타입과 개수가 일치하기 때문에 add(3,3)과 같이 호출하였을 때 어떤 메소드가 호출된 것인지 결정할 수 없기 때문에 오버로딩으로 간주되지 않는다. 
이 경우 역시 컴파일하면, 'add(int, int) is already defined(이미 같은 메소드가 정의되었다).'라는 메시지가 나타날 것이다.

long add(int a, int b) { return a+ b;}
long add(long a, long b) { return a + b;}

두 메소두 모두 int형과 long형 매개변수가 하나씩 선언되어 있지만, 서로 순서가 다른 경우이다.
이 경우에는 호출 시 매개변수의 값에 의해 호출될 메소드가 구분될 수 있으므로 중복된 메소드 정의가 아닌, 오버로딩으로 간주한다.

이처럼 단지 매개변수의 순서만을 다르게 하여 오버로딩을 구현하면, 사용자가 매개변수의 순서를 외우지 않아도 되는 장점이 있지만, 오히려 단점이 될 수도 있기 때문에 주의해야 한다.
예를 들어 add(3, 3L)과 같이 호출되면 첫 번째 메소드가, add(3L, 3)과 같이 호출되면 두 번째 메소드가 호출된다.
단, 이 경우에는 add(3,3)과 같이 호출할 수 없다. 이와 같이 호출할 경우, 두 메소드 중 어느 메소드가 호출된 것인지 알 수 없기 때문에 메소드를 호출하는 곳에서 컴파일 에러가 발생한다.

생성자(constructor)
생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메소드'이다. 따라서 인스턴스변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 하는 작업을 위해서도 사용된다.
(참고 : 인스턴스 초기화란 인스턴스변수들을 초기화하는 것을 뜻한다)
생성자 역시 메소드처럼 클래스 내에 선언되며, 구조도 메소드와 유사하지만 리턴값이 없다는 점이 다르다. 그렇다고 해서 생성자 앞에 리턴값이 없음을 뜻하는 키워드 void를 사용하지는 않고, 단지 아무것도 적지 않는다.
생성자의 조건은 다음과 같다.
1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.
(참고 : 생성자도 메소드이기 때문에 리턴값이 없다는 의미의 void를 붙여야 하지만, 모든 생성자가 리턴값이 없으므로 void를 생략할 수 있게 한 것이다)

생성자는 다음과 같이 정의한다. 생성자도 오버로딩이 가능하므로 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.
클래스이름(타입 변수명, 타입 변수명, ...) {
	//인스턴스 생성 시 수행될 코드,
	//주로 인스턴스 변수의 초기화 코드를 적는다.
}

class Point {
	Point() {		//매개변수가 없는 생성자.
	...
	}
	Point(int x, int y) {	//매개변수가 있는 생성자
	...
	}
	...
}

연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
생성자라는 용어 때문에 오해하기 쉬운데, 생성자는 단순히 인스턴스변수들의 초기화에 사용되는 조금 특별한 메소드일 뿐이다. 생성자가 갖는 몇 가지 특징만 제외하면 메소드와 다르지 않다.

기본 생성자(default constructor)
지금까지는 생성자를 모르고도 프로그래밍을 해 왔지만, 사실 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.
그러나 지금까지 믈래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 '기본 생성자(default constructor)' 덕분이었다.
컴파일 할 때, 소스파일(*.java)의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일 한다.

클래스이름() {}	//기본 생성자
Point) {}		//Point클래스의 기본 생성자

컴파일러가 저동적으로 추가해주는 기본 생성자는 이와 같이 매개변수도 없고 아무런 내용도 없는 아주 간단한 것이다.
그동안 우리는 인스턴스를 생성할 때 컴파일러가 제공한 기본 생성자를 사용해왔던 것이다.
특별히 인스턴스 초기화 작업이 요구되어지지 않는다면 생성자를 정의하지 않고 컴파일러가 제공하는 기본 생성자를 사용하는 것도 좋다.
(참고 : 클래스의 '접근 제어자(Access Modifier)'가 public인 경우에는 기본 생성자로 'public 클래스이름() {}'이 추가된다.)

매개변수가 있는 생성자
생성자도 메소드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용할 수 있다.
인스턴스마다 각기 다른 값으로 초기화되어야 하는 경우가 많기 때문에 매개변수를 사용한 초기화는 매우 유용하다.
아래의 코드는 자동차를 클래스로 정의한 것인데, 단순히 color, gearType, door 세 개의 인스턴스 변수와 두 개의 생성자만을 가지고 있다.

class Car {
	String color;			//색상
	String gearType;			//변속기 종류 - auto(자동), manual(수동)
	int door;				//문의 개수

	Car()				//기본 생성자
	Car(String c, String g, int d) {	//생성자
		color = c;
		gearType = g;
		door = d;
	}
}

Car인스턴스를 생성할 때, 생성자 Car()를 사용한다면, 인스턴스를 생성한 다음에 인스턴스 변수들을 따로 초기화해주어야 하지만, 매개변수가 있는 생성자 Car(String color, String gearType, int door)를 사용한다면 인스턴스를 생성하는 동시에 원하는 값으로 초기화를 할 수 있게 된다.
인스턴스를 생성한 다음에 인스턴스 변수의 값을 변경하는 것보다 매개변수를 갖는 생성자를 사용하는 것이 코드를 보다 간결하고 직관적으로 만든다.
클래스를 작성할 때 다양한 생성자를 제공함으로써 인스턴스 생성 후에 별도로 초기화를 하지 않아도 되게 하는 것이 바람직하다.

지금까지 생성자에 대해서 모르고도 자바프로그래밍이 가능했던 것을 생각한다면, 생성자는 그리 중요하지 않은 것으로 생각될지도 모른다.
하지만, 지금까지 본 것처럼 생성자를 잘 활용하면 보다 간결하고 직관적인, 객체지향적인 코드를 작성할 수 있을 것이다.

인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.
1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

생성자에서 다른 생성자 호출하기 - this()
같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다. 단, 다음의 두 조건을 만족시켜야 한다.
- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

아래 코드는 생성자를 작성할 때 지켜야하는 조건을 모두 만족시키지 못해 에러가 발생한다.

Car (String color) {
	door = 5;		//첫 번째 줄
	Car(color, "auto", 4);	//에러 1. 생성자의 두 번째 줄에서 다른 생성자 호출
				//에러 2. this(color, "auto", 4);로 해야함.
}

생성자 내에서 다른 생성자를 호출할 때는 클래스이름인 'Car'대신 'this'를 사용해야하는데 그러지 않아서 에러가 발생하고, 또 다른 에러는 생성자 호출이 첫 번째 줄이 아닌 두 번째 줄이기 때문에 에러가 발생한다.
생성자에서 다른 생성자를 첫 줄에서만 호출이 가능하도록 한 이유는 생성자 내에서 초기화 작업 도중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화를 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다.

객체 자신을 가리키는 참조변수 - this
이제 왼쪽 코드의 'color = c;'는 생성자의 매개변수로 선언된 지역변수 c의 값을 인스턴스 변수 color에 저장한다.
이 때 변수 color와 c는 이름만으로도 서로 구별되므로 아무런 문제가 없다.

Car(String c, String g, int d) {			Car(String color, String gearType, int door) { //this.color는 iv, color는 lv	
	color = c; //this.color는 iv, color는 lv			this.color = color;
	gearType = g;			->		this.gearType =gearType;
	door = d;					this.door = door;
}						}

하지만, 오른쪽 코드에서처럼 생성자의 매개변수로 선언된 변수의 이름이 color로 인스턴스 변수 color와 같을 경우에는 이름만으로는 두 변수가 서로 구별이 안된다.
이런 경우에는 인스턴스 변수 앞에 'this'를 사용하면 된다.
이렇게 하면 this.color는 인스턴스변수이고, color는 생성자의 매개변수로 정의된 지역변수로 서로 구별이 가능하다.
만일 오른쪽코드에서 'this.color = color'대신 'color = color'와 같이하면 둘 다 매개변수로 간주된다.
이처럼 생성자의 매개변수로 인스턴스변수들의 초기값을 제공받는 경우가 많기 때문에 매개변수와 인스턴스변수의 이름이 일치하는 경우가 자주 있다.
이때는 왼쪽코드와 같이 매개변수이름을 다르게 하는 것보다 'this'를 사용해서 구별되도록 하는 것이 의미가 더 명확하고 이해하기 쉽다.
'this'는 참조변수로 인스턴스 자신을 가리킨다. 참조변수를 통해 인스턴스의 멤버에 접근할 수 있는 것처럼, 'this'로 인스턴스변수에 접근할 수 있는 것이다.
하지만, 'this'를 사용할 수 있는 것은 인스턴스멤버뿐이다. static메소드(클래스 메소드)에서는 인스턴스 멤버들을 사용할 수 없는 것처럼, 'this'역시 사용할 수 없다.
왜냐하면, static 메소드는 인스턴스를 생성하지 않고도 호출될 수 있으므로  static메소드가 호출된 시점에 인스턴스가 존재하지 않을 수도 있기 때문이다.

사실 생성자를 포함한 모든 인스턴스메소드에는 자신이 관련된 인스턴스를 가리키는 참조변수 'this'가 지역변수로 숨겨진 채로 존재한다.

this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스메소드에 지역변수로 숨겨진 채로 존재한다.
this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
(참고 : this와 this()는 비슷하게 생겼을 뿐 완전히 다른 것이다. this는 '참조 변수'이고, this()는 '생성자'이다)

변수의 초기화
변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 한다. 변수의 초기화는 경우에 따라서 필수적이기도 하고 선택적이기도 하지만, 가능하면 선언과 동시에 적절한 값으로 초기화 하는 것이 바람직하다.
멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 초기화하지 않고 사용해도 되지만, 지역변수는 사용하기 전에 반드시 초기화해야 한다.

class InitTest {
	int x;			//인스턴스 변수
	int y =x;			//인스턴스 변수
	void method1() {
		int i;		//지역변수
		int j = i;		//에러. 지역변수를 초기화하지 않고 사용
	}
}

위의 코드에서 x, y는 인스턴스 변수이고, i,j는 지역변수이다. 그 중 x와 i는 선언만 하고 초기화를 하지 않았다.
그리고 y를 초기화 하는데 x를 사용하였고, j를 초기화하는데 i를 사용하였다.
인스턴스 변수 x는 초기화를 해주지 않아도 자동적으로 int형의 기본값인 0으로 초기화되므로, 'int y = x;'와 같이 할 수 있다.
x의 값이 0이므로 y 역시 0이 저장된다.
하지만 method1()의 지역변수 i는 자동적으로 초기화되지 않으므로, 초기화 되지 않은 상태에서 변수 j를 초기화 하는데 사용될 수 없다. 컴파일 하면 에러가 발생한다.

멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택이지만, 지역변수의 초기화는 필수이다.

멤버변수의 초기화
지역변수와 달리 멤버변수는 각 타입의 기본값으로 자동 초기화 된다.
그 다음에 명시적 초기화, 초기화 블럭, 생성자의 순서로 초기화 된다. 그리고 클래스 변수(cv)가 인스턴스 변수(iv)보다 먼저 초기화 된다.
멤버변수의 초기화에 대해서는 이 두가지만 기억하면 된다.

1. 클래스 변수(cv) 초기화 -> 인스턴스 변수(iv) 초기화
2. 자동 초기화 -> 명시적 초기화(간단) -> 초기화 블럭, 생성자(복잡)

명시적 초기화(explicit initialization)
변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 한다. 가장 기본적이면서도 간단한 초기화 방법이므로 여러 초기화 방법 중에서 가장 우선적으로 고려되어야 한다.

class Car {
	int door = 4;			//기본형(primitive type) 변수의 초기화
	Engine e = new Engine();		//참조형(reference type) 변수의 초기화
	//...
}

명시적 초기화가 간단하고 명료하긴 하지만, 보다 복잡한 초기화 작업이 필요할 때는 '초기화 블럭(initialization block)' 또는 생성자를 사용해야 한다.

초기화 블럭(initialization block)
초기화 블럭에는 '클래스 초기화 블럭'과 '인스턴스 초기화 블럭' 두 가지 종류가 있다.
클래스 초기화 블럭은 클래스 변수의 초기화에 사용되고, 인스턴스 초기화 블럭은 인스턴스변수의 초기화에 사용된다.

클래스 초기화 블럭 : 클래스 변수의 복잡한 초기화에 사용된다.
인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용된다.

초기화 블럭을 작성하려면, 인스턴스 초기화 블럭은 단순히 클래스 내에 블럭{} 만들고 그 안에 코드를 작성하기만 하면 된다.
그리고 클래스 초기화 블럭은 인스턴스 초기화 블럭 앞에 단순히 static을 덧붙이기만 하면 된다.